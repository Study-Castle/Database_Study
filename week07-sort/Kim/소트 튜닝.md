# 정렬 튜닝

구분: 7주차
작성자: 도연 김
주제: 정렬, 쿼리 최적화

# 소트 튜닝

## 1. 소트 연산의 이해

### 1) 소트 수행 과정

- 소트는 기본적으로 **`PGA`**에 할당한 **`Sort Area`**에서 수행.
- **`Sort Area`**가 다 차면 디스크 **`Temp`** 테이블 스페이스 활용.
- 디스크 소트 발생 → 부분범위 처리가 불가하여 **`OLTP`** 환경에서 성능 저하의 원인!
    
    ⇒ 쿼리 작성 시 최대한 소트 연산이 없어야 하고 있더라도 메모리 내에서 정렬을 수행할 수 있도록 해야 함.
    

[ 소트 유형 ]

1. **메모리 소트 (In-Memory Sort = Internal Sort)** : 전체 데이터 정렬을 메모리 내에서 완료
2. **디스크 소트(To-Disk Sort = External Sort)** : 할당된 Sort Area에서 정렬을 완료하지 못해 디스크 공간 활용
    1. 소트 대상 데이터를 SGA 버퍼캐시를 통해 불러옴.
    2. **`Sort Area`**에서 정렬 시도
    3. 정렬 대상이 많으면 **`Temp`** 테이블스페이스에 임시 세그먼트 만들어 저장.(Temp 영역에 저장해 둔 중간 단계 집합 ← **`Sort Run`**)
    4. **`Sort Run`**에 존재하는 데이터 Merge

### 2. 소트 오퍼레이션

1. **Sort Aggregate**
    - 전체 로우를 대상으로 집계를 수행할 때(실제로 데이터 정렬은 하지 않는다.)
    
    ```sql
    SELECT 
    	SUM(SAL), MAX(SAL), MIN(SAL), AVG(SAL)
    FROM
    	EMP;
    ```
    
    1. Sort Area에 SUM,MAX,MIN,COUNT 변수 할당
    2. 첫 번째 레코드에서 읽은 SAL 값을 SUM, MAX, MIN 변수에 저장 + COUNT 변수에는 1 저장.
    3. 레코드 하나씩 읽어 내려가면서 
        - SUM 변수에 값 누적
        - MAX 변수에 기존보다 큰 값 있으면 대체
        - MIN 변수에 기존보다 작은 값 있으면 대체
        - COUNT 변수에 SAL 값이 NULL이 아닌 레코드 만나면 1씩 증가

1. **Sort Order By**
    - 데이터를 정렬할 때 사용
    
    ```sql
    SELECT *
    FROM
    	EMP
    ORDER BY
    	SAL DESC;
    ```
    

1. **Sort Group By**
    - 소트 알고리즘을 이용하여 그룹별 집계할 때
    - **GROUP BY** 절에 **ORDER BY** 명시 X ⇒ **Hash GROUP BY**(GROUP BY 컬럼의 해시 값으로 해시 버킷찾아 그룹별 집계항목 갱신) 방식 처리
    
    ```sql
    SELECT
    	DEPTNO, SUM(SAL), MAX(SAL), MIN(SAL), AVG(SAL)
    FROM
    	EMP
    GROUP BY
    	DEPTNO
    ORDER BY
    	DEPTNO;
    ```
    
    1. DEPTNO 기준으로 각 Sort Area에 SUM, MAX, MIN, COUNT 변수 할당 후 DEPTNO 순서로 정렬
    2. 레코드를 읽으며 DEPTNO에 해당하는 Sort Area 탐색 ⇒ SUM, MAX, MIN, COUNT 갱신
    
    <aside>
    💡
    
    정렬된 그룹핑 결과를 얻으려면 실행 계획 상에 **Sort Group By**가 표시되더라도 **Order By**를 꼭 명시해야함.
    
    </aside>
    
2. **Sort Unique**
    - 옵티마이저가 서브쿼리를 일반 조인문으로 변환하는 과정인 서브쿼리 Unnesting에서 조인 컬럼에 Unique 인덱스가 존재하지 않는 경우 중복 레코드를 제거할 때
    - PK/Unique 제약 또는 Unique 인덱스를 통해 서브쿼리의 유일성 보장 시 ⇒ Sort Unique 오퍼레이션 생략
    - Union, Minus, Intersect, Distinct 연산자 사용 시에도 발생
3. **Sort Join**
    - 소트 머지 조인 수행할 때
    
    ```sql
    SELECT /*+ ordered use_merge(e) */*
    FROM
    	DEPT D, EMP E
    WHERE
    	D.DEPTNO = E.DEPTNO;	
    ```
    
4. **Window Sort**
    - 윈도우 함수 사용 시
    
    ```sql
    SELECT
    	EMPNO, ENAME, JOB, MGR, SAL, AVG(SAL) OVER (PARTITION BY DEPTNO)
    FROM
    	EMP;
    ```
    

---

## 2. 소트 발생을 피하는 SQL 작성

### 1) Union VS Union All

- **Union All** : 중복을 확인하지 않음 ⇒ 단순히 두 집합 결합 ⇒ 소트 작업 X
- **Union** : 상단 집합과 하단 집합 간 중복 제거 ⇒ 소트 작업 수행

<aside>
💡

단순히 Union All 를 사용해서 소트 작업을 수행하지 않도록 하면 될까?

⇒ 상단과 하단 인스턴스 중복 가능성을 고려해야 함.

</aside>

```sql
SELECT
	결제번호, 주문번호, 결제금액, 주문일자
FROM 
	결제
WHERE
	결제수단코드 = 'M' AND 결제일자 = '202180316'

UNION

SELECT
	결제번호, 주문번호, 결제금액, 주문일자
FROM
	결제
WHERE
	결제수단코드 = 'C' AND 결제일자 = '20180316'
```

⇒ 위 아래 집합은 상호 배타적이므로 Union → Union All 교체

```sql
SELECT
	결제번호, 주문번호, 결제금액, 주문일자
FROM 
	결제
WHERE
	결제일자 = '202180316'

UNION

SELECT
	결제번호, 주문번호, 결제금액, 주문일자
FROM
	결제
WHERE
	주문일자 = '20180316'
```

⇒ `결제일자==주문일자`인 인스턴스가 존재할 수 있기 때문에 상호 배타적 조건이 아님.→Union All 교체 X

***해결방법***

```sql
SELECT
	결제번호, 주문번호, 결제금액, 주문일자
FROM 
	결제
WHERE
	결제일자 = '202180316'

UNION

SELECT
	결제번호, 주문번호, 결제금액, 주문일자
FROM
	결제
WHERE
	주문일자 = '20180316'
AND
	결제일자 <> '20180316';
```

### 2) Exists 활용

- **DISTINCT** 연산 : 조건에 해당하는 데이터 모두 읽어 중복 제거 ⇒ 모든 데이터 읽는 과정에서 많은 I/O 발생
    
    ```sql
    SELECT
    	DISTINCT P.상품번호, P.상품명, P.상품가격
    FROM
    	상품 P, 계약 C
    WHERE
    	P.상품유형코드 = :pclsd
    AND
    	C.상품번호 = P.상품번호
    AND
    	C.계약번호 BETWEEN :DT1 AND :DT2
    AND
    	C.계약구분코드 = :CTPCD;
    ```
    
- **EXISTS** 서브쿼리 : 데이터 존재 여부만 확인하여 조건절을 만족하는 데이터를 모두 읽지 않는다.
    
    ```sql
    SELECT
    	DISTINCT P.상품번호, P.상품명, P.상품가격
    FROM
    	상품 P, 계약 C
    WHERE
    	P.상품유형코드 = :PCLCD
    AND
    	EXUSTS ( 
    		SELECT 'X' 
    		FROM 계약 C
    		WHERE
    			C.상품번호 = P.계약번호
    		AND
    			C.계약일자 BETWEEN :DT1 AND :DT2
    		AND
    			C.계약구분코드 = :CTPCD)				
    ```
    
- **MINUS** 연산자 ⇒ **NOT EXISTS** 서브쿼리 튜닝
    
    ![2023. 7. 31. - 1979.jpg](./images/2023.%207.%2031.%20-%201979.jpg)
    
    ![2023. 7. 31. - 1980.jpg](./images/2023.%207.%2031.%20-%201980.jpg)
    

---

## 3. 인덱스를 이용한 소트 연산 생략

### 1) Sort Order By

```sql
SELECT
	거래일시, 체결건수, 체결수량, 거래대금
FROM
	종목거래
WHERE
	종목코드 = 'KR123456'
ORDER BY
	거래일시;
```

- INDEX ( 종목코드 + 거래일시) ⇒ 소트 연산   생략 가능 + 부분범위 처리 가능

<aside>
💡

**부분범위 처리 기능?**

쿼리 수행 결과 중 앞쪽 일부를 우선 전송 후 멈추었다가 클라이언트가 전송을 요청할 때마다 남은 데이터를 조금씩 나누어 전송하는 방식

</aside>

### 2) TOP N 쿼리

```sql
SELECT 
	TOP 10 거래일시, 체결건수, 체결수량, 거래대금
FROM 
	종목거래
WHERE
	종목코드 = 'KR123456'
AND
	거래일시 >= '202180304'
ORDER BY
	거래일시;
```

- INDEX ( 종목코드 + 거래일시 ) ⇒ 소트 연산을 생략

***페이징 처리***

- 부분범위 처리가 가능한 SQL
    - 인덱스가 사용가능하도록 조건절 구사
    - 조인은 NL 조인 위주로 처리
    - ORDER BY 절이 있어도 소트 연산 생략할 수 있도록 인덱스 구성

### 3) 최소값/최대값 구하기

```sql
SELECT MAX(SAL) FROM EMP;
```

- 실행 계획 : Sort Aggregate 오퍼레이션이 나타남.

```sql
CREATE INDEX EMP_X1 ON EMP(SAL);

SELECT MAX(SAL) FROM EMP;
```

- 인덱스를 이용 ⇒ 전체 데이터를 읽지 않고 최소값 / 최대값 찾을 수 있음.
- 조건 : 조건절 컬럼과 MIN/MAX 함수 인자 컬럼이 모두 인덱스에 포함되어야함.

***인덱스로 최대/최소 구하기***

```sql
SELECT 
	MAX(SAL)
FROM
	EMP
WHERE
	DEPTNO = 30
	AND
	MGR = 7689;
```

Case 1) INDEX (DEPTNO, SAL, MGR)

- DEPTNO는 액세스 조건, MGR은 필터 조건 ⇒ First Row Stopkey 알고리즘 + Index Range Scan

Case 2) INDEX (SAL, DEPTNO, MGR)

- DEPTNO, MGR 필터링 조건 ⇒ First Row Stopkey 알고리즘  + Index Full Scan

Case 3) INDEX (DEPTNO, SAL) → 조건절 컬럼이나 MAX 컬럼 중 하나가 인덱스에 포함되지 않은 경우

- **DEPTNO = 30** 조건의 전체 레코드를 읽어 테이블에서 **MGR = 7689** 조건 필터링 → MAX(SAL) 값 구함.

***Top N 쿼리로 최대/최소 구하기***

```sql
CREATE INDEX EMP_X1 ON EMP(DEPTNO, SAL);

SELECT *
FROM (
	SELECT 
		SAL
	FROM
		EMP
	WHERE
		DEPTNO = 30
		AND
		MGR = 7698
	ORDER BY
		SAL DESC
	)
WHERE
	ROWNUM <= 1;
```

- Top N Stopkey 알고리즘 동작
- DEPTNO = 30 조건 만족하는 가장 오른쪽에서부터 역순으로 스캔 → 테이블 액세스하며 MGR=7698 조건을 만족하는 레코드 찾으면 멈춤.

### 4) Sort Group By 생략

- 그룹핑 연산에도 인덱스를 사용할 수 있다.
- 실행계획에서 **`Sort Group By Nosort`** 확인!

```sql
SELECT 
	region, avg(age), count(*)
FROM
	customer
GROUP BY
	region;
	
[ 실행계획 ]
SELECT STATEMENT
	SORT GROUP BY NOSORT
		TABLE ACCESS BY INDEX ROWID
			INDEX FULL SCAN
```

---

## 4. Sort Area를 적게 사용하는 SQL 작성법

### 1) 소트 데이터 줄이기

```sql
[ 1번 ] 
SELECT
	LPAD(상품번호, 30) || LPAD(상품명, 30) || LPAD(고객ID, 10)
		|| LPAD(고객명,20) || TO_CHAR(주문일시, 'yyyymmdd hh24:mi:ss')
FROM
	상품주문
WHERE
	주문일시 BETWEEN :START AND :END
ORDER BY
	상품번호;
	
	
	
[ 2번 ]
SELECT
	LPAD(상품번호, 30) || LPAD(상품명, 30) || LPAD(고객ID, 10)
		|| LPAD(고객명,20) || TO_CHAR(주문일시, 'yyyymmdd hh24:mi:ss')
FROM (
	SELECT
		상품번호, 상품명, 고객ID, 고객명, 주문일시
	FROM
		주문상품
	WHERE
		주문일시 BETWEEN :START AND :END
	ORDER BY
		상품번호
);
```

**Sort Area 사용** : 1번 > 2번

```sql
[ 1번 ]
SELECT *
FROM
	예수금원장
ORDER BY
	총예수금 DESC;
	
	
[ 2번 ]
SELECT
	계좌번호, 총예수금
FROM
	예수금원장
ORDER BY
	총예수금 DESC;
```

Sort Area 사용 : 1번 > 2번

### 2) Top N 쿼리 소트 부하 감소 원리

- 인덱스로 소트 연산을 생략할 수 없는 경우

전교생 1000명 중 가장 큰 학생 10명 선발하는 케이스

1. 맨 앞줄 맨 왼쪽에 있는 학생 10명을 키 순서대로 세운다.
2. 나머지 990명을 1명씩 비교하며 현재 Top 10 위치에 있는 학생과 키를 비교 → 더 큰 학생이 존재하면 Top 10위치에 있는 학생과 교체
3. Top 10에 새로 진입한 학생 키에 맞춰 자리 재배치

```sql
SELECT *
FROM (
	SELECT 
		ROWNUM NO, A.*
		FROM (
			SELECT
				거래일시, 체결건수, 체결수량, 거래대금
			FROM
				종목거래
			WHERE
				종목코드 = 'KR123456'
				AND
				거래일시 >= '20180304'
			ORDER BY
				거래일시
			) A
		WHERE
			ROWNUM <= (:page * 10)
		)
	WHERE
		NO >= (:page-1)*10 + 1;
```

```sql
COUNT STOPKEY (cr=690 pr=0 pw=0 time=83318 us)
	VIEW (cr=690 pr=0 pw=0 time=83290 us)
		SORT ORDER BY STOPKEY (cr=690 pr=0 pw=0 time=83264 us)
			TABLE ACCESS FULL 종목거래 (cr=690 pr=0 pw=0 time=299191 us)
```

- Sort Order By (소트)연산을 수행하지만 Stop Key를 통해 Top N 소트 알고리즘이 동작.
- 소트 연산(=값 비교) 횟수와 Sort Area 사용량 최소화
1. 처음 읽은 10개 레코드 → 오름차순 정렬 후 배열에 담는다.
2. 이 후 읽은 레코드들은 배열 맨 끝 값과 비교해 더 작은 값이 나타날 때만 배열 내에서 정렬 수행 → 기존에 맨 끝에 있는 값은 버림.

### 3) Top N 쿼리가 아닌 경우

```sql
SELECT *
FROM (
	SELECT 
		ROWNUM NO, A.*
		FROM (
			SELECT
				거래일시, 체결건수, 체결수량, 거래대금
			FROM
				종목거래
			WHERE
				종목코드 = 'KR123456'
				AND
				거래일시 >= '20180304'
			ORDER BY
				거래일시
			) A
		)
	WHERE NO BETWEEN (:page-1) * 10 + 1 AND (:page * 10);
```

- 실행계획 : Stopkey 존재 X ⇒ Top N 소트 알고리즘 동작 X
- Disk I/O 발생

### 4) 분석함수에서의 Top N 소트

- **소트 부하** : MAX 함수 > rank, row_number 함수
