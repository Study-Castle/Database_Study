# 🍏격리 수준

---

### 격리수준

> 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것.
> 

- **격리 수준** : `READ UNCOMMITTED` < `READ COMMITTED` <  `REPEATABLE READ` <  `SERIALIZABLE`
- **동시 처리 성능** :  `READ UNCOMMITTED` > `READ COMMITTED` >  `REPEATABLE READ` >  `SERIALIZABLE`

## READ UNCOMMITTED

![다운로드 (13).png](./images/다운로드%20(13).png)

1. **사용자 A**가 `emp_no = 50000`, f`irst_name = ‘JuBal’` 사원 Insert
2. **사용자 B**가 **사용자 A**가 변경한 내용 커밋 이전에 `emp_no = 50000`인 사원 조회
3. **사용자 B**의 SELECT 결과 **사용자 A**가 아직 커밋하지 않은 새로운 사원 JuBal 조회

### 🚨🚨🚨 **Dirty Read 발생!**

사용자 A가 Insert된 내용을 롤백시 사용자 B는 JuBal이 정상적인 사원이라고 생각한고 계속 처리!!!

> **Dirty Read** : 어떤 트랜잭션에서 처리한 작업이 완료되지 않았음에도 다른 트랜잭션에서 볼 수 있는 현상.
> 

---

## READ COMMITTED

- 오라클 DBMS에서 기본으로 사용되는 격리 수준.
- 온라인 서비스에서 가장 많이 사용되는 격리 수준.
- Dirty Read 발생❌

> **Undo 로그?**
- 언두 영역은 UPDATE / DELETE와 같은 문장을 데이터를 변경했을 때 변경되기 전 데이터를 보관하는 곳(백업 공간)
> 

![다운로드 (14).png](./images/다운로드%20(14).png)

1. **사용자 A**가 `emp_no = 50000`인 사원의 `first_name`을 **JuBal**에서 **Toto** 수정
2. **Toto**는 `employees` 테이블에 즉시 기록 → 이전 값 **Jubal**은 **Undo**영역에 백업
3. **사용자 A**가 커밋이전 **사용자 B**가 emp_no = 50000인 사원 조회 시 이전 값인 **JuBal**이 조회됨. ← **Undo**영역의 백업 레코드에 결과를 조회.

![다운로드 (16).png](./images/다운로드%20(16).png)

### 🚨🚨🚨 Non-Repeatable Read 발생!

> 하나의 트랜잭션 내에서 동일 SELECT 쿼리 실행 시 항상 같은 결과를 보장해야한다는 정합성에 어긋나는 것.
> 
1. **사용자 B**가 트랜잭션을 시작하고 `first_name = ‘Toto’`인 사원 조회 시 결과값 = 0
2. **사용자 A**가 `emp_no = 50000`인 사원의 이름을 Toto로 수정하고 커밋
3. **사용자 B**가 다시 똑같은 `SELECT` 쿼리로 조회 시 결과값 = 1

→ **사용자B**가 하나의 트랜잭션 내 동일한 `SELECT` 쿼리 실행 시 같은 결과를 보장하지 못하는 ***Non-Repeatable Read*** 발생.

---

## REPEATABLE READ

- MySQL의 InnoDB 스토리지 엔진에서 기본 사용되는 격리 수준.
- ***Non-Repeatable Read*** 발생 ❌
    
    ![다운로드 (17).png](./images/다운로드%20(17).png)
    
1. **사용자 A**의 트랙잭션 번호 = 12 / **사용자 B**의 트랜잭션 번호 = 10
2. **사용자 A**가 사원의 이름을 Toto로 변경 후 커밋
3. 사용자 B는 `emp_no = 50000`인 사원을 사원의 이름이 변경되기 전(`트랜잭션 번호 6`)과 변경 후(`트랜잭션 번호 12`)조회 시 동일한 결과 (JuBal)

→ **사용자 B**가 BEGIN 명령으로 트랜잭션을 시작하면서 트랜잭션 번호 10번을 부여받았는데, **사용자 B**의 10번 트랜잭션 안에서 실행되는 모든 `SELECT` 쿼리는 트랜잭션 번호 10번보다 작은 트랜잭션 번호에서 변경된 데이터만을 볼 수 있다.

### 🚨🚨🚨 Phantom Read 발생!

> SELECT … FOR UPDATE 쿼리와 같은 쓰기 잠금을 거는 경우 다른 트랜잭션에서 수행한 변경 작업에 의해서 레코드가 보였다가 안 보였다가 하는 현상.
> 
- ***SELECT … FOR UPDATE***
    
    선택된 행들에 대해서 LOCK을 설정하는 기능. SELECT FOR UPDATE 문을 통해 커서 결과 집합의 레코드를 잠글 수 있음.
    

![다운로드 (18).png](./images/다운로드%20(18).png)

1. 사용자B의 2번의 SELECT … FOR UPDATE 결과 각각 1건과 2건으로 다른 결과.
2. SELECT … FOR UPDATE 쿼리같은 경우 SELECT 하는 레코드에 잠금을 걸어야 하지만 Undo 영역에는 잠금을 걸 수 없기 때문.

---

## SERIALIZABLE

- 가장 엄격한 격리 수준 + 가장 낮은 동시 처리 성능
- 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근 불가!
- ***Phantom Read*** 발생❌
- InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ에서 이미 ***Phantom Read***발생❌